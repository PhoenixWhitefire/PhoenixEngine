#include<iostream>
#include<iomanip>
#include<ctime>
#include<sstream>
#include<nljson.hpp>
#include<glad/gl.h>

#include"asset/MeshProvider.hpp"
#include"asset/PrimitiveMeshes.hpp"
#include"FileRW.hpp"
#include"Debug.hpp"

#define MESHPROVIDER_ERROR(err) s_ErrorString = err; *SuccessPtr = false

static std::string s_ErrorString = "No error";

static float getVersion(std::string const& MapFileContents)
{
	size_t matchLocation = MapFileContents.find("#Version");

	float version = 0.f;

	if (matchLocation != std::string::npos)
	{
		std::string subStr = MapFileContents.substr(matchLocation + 9, 4);
		version = std::stof(subStr);
	}

	return version;
}

MeshProvider::MeshProvider()
{
	this->Assign(PrimitiveMeshes::Cube(), "!Cube");
}

MeshProvider::~MeshProvider()
{
	for (size_t promIndex = 0; promIndex < m_MeshPromises.size(); promIndex++)
	{
		std::promise<Mesh>* prom = m_MeshPromises[promIndex];
		std::shared_future<Mesh>& future = m_MeshFutures[promIndex];

		// we don't want our async threads accessing deleted promises
		future.wait();

		delete prom;
	}

	for (MeshProvider::GpuMesh& gpuMesh : m_GpuMeshes)
	{
		delete gpuMesh.VertexBuffer;
		delete gpuMesh.ElementBuffer;
		delete gpuMesh.VertexArray;
	}

	m_Meshes.clear();
	m_StringToMeshId.clear();
	m_MeshFutures.clear();
	m_MeshPromises.clear();
	m_MeshPromiseResourceIds.clear();
	m_GpuMeshes.clear();
}

static MeshProvider* instance = nullptr;

MeshProvider* MeshProvider::Get()
{
	if (!instance)
		instance = new MeshProvider();
	return instance;
}

void MeshProvider::Shutdown()
{
	delete instance;
	instance = nullptr;
}

std::string MeshProvider::Serialize(const Mesh& mesh)
{
	std::string contents = "Generated by Phoenix Engine\n#Version 1.00\n#Asset Mesh\n";

	time_t t = std::time(nullptr);
	tm tm = *std::localtime(&t);

	std::ostringstream oss;
	oss << std::put_time(&tm, "%d-%m-%Y");
	std::string dateTimeStr = oss.str();

	contents += "#Date " + dateTimeStr + "\n\n";

	nlohmann::json json;
	nlohmann::json vertSon;
	nlohmann::json indSon;

	for (size_t index = 0; index < mesh.Vertices.size(); index++)
	{
		const Vertex& vert = mesh.Vertices[index];

		vertSon[index] =
		{
			vert.Position.x,
			vert.Position.y,
			vert.Position.z,
			vert.Normal.x,
			vert.Normal.y,
			vert.Normal.z,
			vert.Color.x,
			vert.Color.y,
			vert.Color.z,
			vert.TextureUV.x,
			vert.TextureUV.y
		};
	}

	for (uint32_t ind : mesh.Indices)
		indSon.push_back(ind);

	json["Vertices"] = vertSon;
	json["Indices"] = indSon;

	contents += json.dump(2);

	return contents;
}

Mesh MeshProvider::Deserialize(const std::string& Contents, bool* SuccessPtr)
{
	*SuccessPtr = true;

	if (Contents.size() == 0)
	{
		MESHPROVIDER_ERROR("Mesh file is empty");
		return Mesh{};
	}

	float version = getVersion(Contents);

	if (version == 0.f)
	{
		MESHPROVIDER_ERROR("No Version header");
		return Mesh{};
	}

	size_t jsonStartLoc = Contents.find("{");
	std::string jsonFileContents = Contents.substr(jsonStartLoc);
	nlohmann::json json = nlohmann::json::parse(jsonFileContents);

	Mesh mesh;
	mesh.Vertices.reserve(json["Vertices"].size());
	mesh.Indices.reserve(json["Indices"].size());

	size_t vertexIndex = 0;

	for (nlohmann::json vertexDesc : json["Vertices"])
	{
		if (vertexDesc.size() % 11 != 0)
		{
			MESHPROVIDER_ERROR("Vertex #" + std::to_string(vertexIndex) + " does not have 11 elements");
			return Mesh{};
		}

		Vertex vertex =
		{
			glm::vec3(vertexDesc[0], vertexDesc[1], vertexDesc[2]),
			glm::vec3(vertexDesc[3], vertexDesc[4], vertexDesc[5]),
			glm::vec3(vertexDesc[6], vertexDesc[7], vertexDesc[8]),
			glm::vec2(vertexDesc[9], vertexDesc[10])
		};

		mesh.Vertices.emplace_back(
			glm::vec3(vertexDesc[0], vertexDesc[1], vertexDesc[2]),
			glm::vec3(vertexDesc[3], vertexDesc[4], vertexDesc[5]),
			glm::vec3(vertexDesc[6], vertexDesc[7], vertexDesc[8]),
			glm::vec2(vertexDesc[9], vertexDesc[10])
		);

		vertexIndex += 1;
	}

	for (uint32_t index : json["Indices"])
		mesh.Indices.push_back(index);

	return mesh;
}

void MeshProvider::Save(const Mesh& mesh, const std::string& Path)
{
	std::string contents = this->Serialize(mesh);
	FileRW::WriteFileCreateDirectories(Path, contents, true);
}

void MeshProvider::Save(uint32_t Id, const std::string& Path)
{
	this->Save(m_Meshes.at(Id), Path);
}

uint32_t MeshProvider::Assign(const Mesh& mesh, const std::string& InternalName)
{
	uint32_t assignedId = static_cast<uint32_t>(m_Meshes.size());

	auto prevPair = m_StringToMeshId.find(InternalName);

	if (prevPair != m_StringToMeshId.end())
	{
		// overwrite the pre-existing mesh
		m_Meshes[prevPair->second] = mesh;
		assignedId = prevPair->second;
	}
	else
	{
		m_Meshes.push_back(mesh);
		m_StringToMeshId.insert(std::pair(InternalName, assignedId));
	}

	return assignedId;
}

uint32_t MeshProvider::LoadFromPath(const std::string& Path, bool ShouldLoadAsync)
{
	auto meshIt = m_StringToMeshId.find(Path);

	if (meshIt == m_StringToMeshId.end())
	{
		bool success = true;

		std::string contents = FileRW::ReadFile(Path, &success);

		if (!success)
		{
			Debug::Log(std::vformat(
				"MeshProvider Failed to load mesh '{}': Invalid path/File could not be opened",
				std::make_format_args(Path)
			));

			return this->Assign(Mesh{}, "blank");
		}
		else
		{
			if (ShouldLoadAsync)
			{
				std::promise<Mesh>* promise = new std::promise<Mesh>;

				uint32_t resourceId = this->Assign(Mesh{}, Path);

				std::thread(
					[promise, resourceId, this, Path, contents]()
					{
						bool deserialized = true;
						Mesh loadedMesh = this->Deserialize(contents, &deserialized);

						if (!deserialized)
							Debug::Log(std::vformat(
								"MeshProvider Failed to load mesh '{}' asynchronously: {}",
								std::make_format_args(Path, s_ErrorString)
							));

						promise->set_value_at_thread_exit(loadedMesh);
					}
				).detach();

				m_MeshPromises.push_back(promise);
				m_MeshFutures.push_back(promise->get_future().share());
				m_MeshPromiseResourceIds.push_back(resourceId);

				return resourceId;
			}
			else
			{
				Mesh mesh = this->Deserialize(contents, &success);
				if (!success)
					Debug::Log(std::vformat(
						"MeshProvider Failed to load mesh '{}': {}",
						std::make_format_args(Path, s_ErrorString)
					));

				return this->Assign(mesh, Path);
			}
		}
	}
	else
		return meshIt->second;
}

Mesh* MeshProvider::GetMeshResource(uint32_t Id)
{
	return &m_Meshes.at(Id);
}

MeshProvider::GpuMesh& MeshProvider::GetGpuMesh(uint32_t Id)
{
	return m_GpuMeshes.at(Id);
}

void MeshProvider::FinalizeAsyncLoadedMeshes()
{
	size_t numMeshPromises = m_MeshPromises.size();
	size_t numMeshFutures = m_MeshFutures.size();
	size_t numMeshResourceIds = m_MeshPromiseResourceIds.size();

	if (numMeshPromises != numMeshFutures || numMeshFutures != numMeshResourceIds)
	{
		Debug::Log(std::vformat(
			"FinalizeAsyncLoadedMeshes had {} promises, {} futures and {} resource IDs, cannot proceed safely",
			std::make_format_args(numMeshPromises, numMeshFutures, numMeshResourceIds)
		));
		return;
	}

	for (size_t promiseIndex = 0; promiseIndex < m_MeshPromises.size(); promiseIndex++)
	{
		std::promise<Mesh>* promise = m_MeshPromises[promiseIndex];
		std::shared_future<Mesh>& f = m_MeshFutures[promiseIndex];

		if (!f.valid() || f.wait_for(std::chrono::seconds(0)) != std::future_status::ready)
			continue;

		const Mesh& loadedMesh = f.get();
		uint32_t resourceId = m_MeshPromiseResourceIds[promiseIndex];

		Mesh& mesh = m_Meshes.at(resourceId);

		mesh.Vertices = loadedMesh.Vertices;
		mesh.Indices = loadedMesh.Indices;

		mesh.GpuId = static_cast<uint32_t>(m_GpuMeshes.size());
		m_CreateAndUploadGpuMesh(mesh);

		m_MeshPromises.erase(m_MeshPromises.begin() + promiseIndex);
		m_MeshFutures.erase(m_MeshFutures.begin() + promiseIndex);
		m_MeshPromiseResourceIds.erase(m_MeshPromiseResourceIds.begin() + promiseIndex);

		delete promise;

		return;
	}
}

const std::string& MeshProvider::GetLastErrorString()
{
	return s_ErrorString;
}

void MeshProvider::m_CreateAndUploadGpuMesh(const Mesh& mesh)
{
	m_GpuMeshes.emplace_back();

	MeshProvider::GpuMesh& gpuMesh = m_GpuMeshes[m_GpuMeshes.size() - 1];

	VAO* vao = new VAO;
	VBO* vbo = new VBO;
	EBO* ebo = new EBO;

	gpuMesh.VertexArray = vao;
	gpuMesh.VertexBuffer = vbo;
	gpuMesh.ElementBuffer = ebo;

	vao->Bind();

	vao->LinkAttrib(*vbo, 0, 3, GL_FLOAT, sizeof(Vertex), (void*)0);
	vao->LinkAttrib(*vbo, 1, 3, GL_FLOAT, sizeof(Vertex), (void*)(3 * sizeof(float)));
	vao->LinkAttrib(*vbo, 2, 3, GL_FLOAT, sizeof(Vertex), (void*)(6 * sizeof(float)));
	vao->LinkAttrib(*vbo, 3, 2, GL_FLOAT, sizeof(Vertex), (void*)(9 * sizeof(float)));

	vbo->SetBufferData(mesh.Vertices, BufferUsageHint::Static);
	ebo->SetBufferData(mesh.Indices, BufferUsageHint::Static);
}
