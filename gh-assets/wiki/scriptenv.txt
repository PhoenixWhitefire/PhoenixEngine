## Datatypes

Custom types with functions and properties.

### `Color`

* An RGB color

#### `Color.new(R: number, G: number, B: number): any`
* Returns a Color with the provided R, G, and B values
* Values are expected to be in the range 0 to 1

#### `.R: number`
* The Red channel

#### `.G: number`
* The Green channel

#### `.B: number`
* The Blue channel

### `EventConnection`

* A connection to an Event

#### `.Connected: boolean`
* Whether the Connection is connected or not

#### `Disconnect(): nil`
* Disconnects the Connection, causing the callback to no longer be invoked, may only be called once

#### `.Signal: any`
* The Event which `:Connect` was called upon to return this Connection

### `EventSignal`

* An Event that can be connected to

#### `Connect((any) -> (any)): EventConnection`
* Connect a callback to the Event

### `GameObject`

* A Game Object
* For organization, the members of this type will be on the Components wiki page

#### `GameObject.validComponents: { string }`
* A list of all valid component names which can be passed into `.new`

#### `GameObject.new(Component: string): any`
* Creates a new GameObject with the provided Component

### `Matrix`

* A 4x4 transformation matrix

#### `Matrix.new(any): any`
* Creates a new identity matrix

#### `Matrix.fromTranslation(Position: vector): Matrix`
#### `Matrix.fromTranslation(X: number, Y: number, Z: number): Matrix`
* Creates a Matrix which has been translated to the given coordinates (specified as either a `vector` or the individual X, Y, and Z component)

#### `Matrix.lookAt(Eye: vector, Target: vector): Matrix`
* Creates a Matrix at position `Eye` oriented such that the `.Forward` vector moves toward `Target`

#### `Matrix.fromEulerAnglesXYZ(X: number, Y: number, Z: number): Matrix`
* Creates a Matrix which has been rotated by the given Euler angles (in radians) with the rotation order X-Y-Z

#### `__mul(Matrix): Matrix`
* Two Matrices may be multiplied together with the `*` operator

#### `.Right: vector`
* The rightward vector of the Matrix

#### `.C1R1: number`
* The value at Column 1, Row 1

#### `.C4R1: number`
* The value at Column 4, Row 1

#### `.C3R1: number`
* The value at Column 3, Row 1

#### `.C2R1: number`
* The value at Column 2, Row 1

#### `.C1R2: number`
* The value at Column 1, Row 2

#### `.C3R2: number`
* The value at Column 3, Row 2

#### `.C4R2: number`
* The value at Column 4, Row 2

#### `.Up: vector`
* The upward vector of the Matrix

#### `.C4R3: number`
* The value at Column 4, Row 3

#### `.C3R3: number`
* The value at Column 3, Row 3

#### `.C2R3: number`
* The value at Column 2, Row 3

#### `.C1R3: number`
* The value at Column 1, Row 3

#### `.C2R2: number`
* The value at Column 2, Row 2

#### `.Forward: vector`
* The forward vector of the Matrix

#### `.Position: vector`
* The position of the Matrix in world-space

#### `.C1R4: number`
* The value at Column 1, Row 4

#### `.C2R4: number`
* The value at Column 2, Row 4

#### `.C3R4: number`
* The value at Column 3, Row 4

#### `.C4R4: number`
* The value at Column 4, Row 4

## Libraries

Custom libraries.

### `conf`
* Internal Engine configuration state, loaded from file (`phoenix.conf`) upon startup

#### `conf.save(any): boolean`
* Save the current state of the configuration to file (`phoenix.conf`), returning whether the file was successfully overwritten

#### `conf.set(Key: string, Value: any): any`
* Change a specific value in the configuration

#### `conf.get(Key: string): any`
* Read a specific value from the configuration

### `engine`
* Inspect and modify various parts of the Engine

#### `engine.poplvm(any): any`

#### `engine.framerate(any): any`
* Returns the current framerate

#### `engine.setvsync(any): any`
* Enables/disables VSync

#### `engine.binddatamodel(any): any`

#### `engine.setwindowsize(any): any`
* Sets the size of the window to the specified two Width and Height integers

#### `engine.setexplorerselections(any): any`

#### `engine.exit(ExitCode: number?): any`
* Shuts down the Engine and exits the process with the specified Exit Code (or 0 by default)

#### `engine.setfullscreen(any): any`
* Enables/disables fullscreen mode

#### `engine.pushlvm(any): any`

#### `engine.setmaxframerate(MaxFramerate: number): any`
* Sets the maximum framerate the Engine will reach before self-limiting

#### `engine.physicstimescale(any): any`

#### `engine.getfullscreen(any): any`
* Returns whether the Engine is currently in fullscreen

#### `engine.getvsync(any): any`
* Returns whether VSync is currently enabled

#### `engine.getmaxframerate(any): any`
* Returns the current framerate cap

#### `engine.getwindowsize(any): number, number`
* Returns the current size of the window as two integers

#### `engine.dwireframes(Enabled: boolean?): any`
* Returns whether all visible 3D objects are being rendered with wireframes
* Optionally, the visualization can be enabled/disabled by passing in a boolean argument

#### `engine.isheadless(any): any`
* Returns whether the Engine is currently running Headless mode

#### `engine.setexplorerroot(any): any`

#### `engine.daabbs(Enabled: boolean?): any`
* Returns whether AABBs are drawn for all objects with collisions enabled (`.PhysicsCollisions == true`)
* Optionally, the visualization can be enabled/disabled by passing in a boolean argument

### `fs`
* Interacting with the player's filesystem

#### `fs.write(Path: string, Contents: string): boolean`
* Overwrites/creates the file at `Path` with the provided `Contents`
* Returns whether the operation was successful

#### `fs.read(Path: string): string?`
* Reads the file at the given address, and returns the contents
* If the file could not be read, returns `nil`

#### `fs.promptopen(DefaultLocation: string? [ './'  ], Filter: string? [ '*.*' ], FilterName: string? [ 'All files ' ], AllowMultipleFiles: boolean [ false ]): { string }`
* Prompts the player to select a file to open
* Returns the list of files the player selected, or an empty list if the player cancelled the dialog
* If the operation fails, returns `nil` instead

#### `fs.isfile(any): any`
* Returns whether the specified Path refers to a file

#### `fs.promptsave(DefaultLocation: string? [ './' ], Filter: string? [ '*.*' ], FilterName: string? [ 'All files' ]): string`
* Prompts the player to select a path to save a file to
* Returns the path the player selected, or `nil` if they cancelled the dialog

#### `fs.listdir(Path: string, Filter: 'a' | 'f' | 'd' [ 'a' ]): { [string]: 'f' | 'd' }`
* Returns a table of all the entries in the specified directory
* The keys of the table is the path of the entry, while the values are the type of the entry
* `f` is file, `d` is directory, and `a` is all

#### `fs.isdirectory(any): any`
* Returns whether the specified Path refers to a directory

#### `fs.ispromptactive(any): any`
* Returns whether a File Dialog is currently visible to the player and blocking any more file dialogs from being opened

### `imgui`
* UI with Dear ImGui

#### `imgui.beginmainmenubar(any): any`

#### `imgui.endmenubar(any): any`

#### `imgui.setnextwindowfocus(any): any`

#### `imgui.image(any): any`
* `ImGui::Image`

#### `imgui.settooltip(any): any`

#### `imgui.button(any): any`
* `ImGui::Button`

#### `imgui.menuitem(any): any`

#### `imgui.inputstring(any): any`
* `ImGui::InputText`

#### `imgui.checkbox(any): any`
* `ImGui::Checkbox`

#### `imgui.endmenu(any): any`

#### `imgui.text(any): any`
* `ImGui::Text`

#### `imgui.getcursorpos(any): any`

#### `imgui.begin(any): any`
* `ImGui::Begin`

#### `imgui.inputnumber(any): any`
* `ImGui::InputDouble`

#### `imgui.textlink(any): any`
* `ImGui::TextLink`

#### `imgui.setitemtooltip(any): any`
* `ImGui::SetItemTooltip`

#### `imgui.combo(any): any`

#### `imgui.setcursorpos(any): any`

#### `imgui.popid(any): any`

#### `imgui.beginmenu(any): any`

#### `imgui.treepop(any): any`

#### `imgui.treenode(any): any`

#### `imgui.endchild(any): any`

#### `imgui.endw(any): any`
* `ImGui::End`, `endw` and not `end` because `end` is a Luau keyword

#### `imgui.itemhovered(any): any`
* `ImGui::IsItemHovered`

#### `imgui.itemclicked(any): any`
* `ImGui::IsItemClicked`

#### `imgui.indent(any): any`
* `ImGui::Indent`

#### `imgui.stylecolors(any): any`

#### `imgui.dummy(any): any`

#### `imgui.beginchild(any): any`

#### `imgui.beginfullscreen(any): any`

#### `imgui.endmainmenubar(any): any`

#### `imgui.beginmenubar(any): any`

#### `imgui.pushid(any): any`

### `input`
* Checking player inputs

#### `input.ismousegrabbed(any): boolean`
* Returns whether the mouse cursor is currently restricted to the window

#### `input.setmousegrabbed(Grabbed: boolean): any`
* Grabs/ungrabs the mouse cursor

#### `input.guihandledm(any): boolean`
* Returns whether Dear ImGui is using the player's mouse inputs

#### `input.setmousepos(X: number, Y: number): any`

#### `input.iscursorvisible(any): boolean`
* Returns whether the mouse cursor is currently visible

#### `input.setcursorvisible(Visible: boolean): any`
* Sets the visibility of the mouse cursor to the specified value

#### `input.getmousepos(any): number, number`
* Returns the current position of the player's mouse cursor, offset from the top-right

#### `input.guihandled(any): boolean`
* Returns whether Dear ImGui is using the player's inputs at all

#### `input.mousedown(Button: 'l' | 'r' | 'e'): boolean`
* Returns whether the specified mouse button (`l`eft, `r`ight, or `e`ither) is currently being pressed

#### `input.keypressed(Key: string): boolean`
* Returns whether the specified key (as lowercase, e.g. `'a'`, `'b'`) is currently being pressed

#### `input.guihandledk(any): boolean`
* Returns whether Dear ImGui is using the player's keyboard inputs

### `json`
* Encoding and decoding JSON files

#### `json.encode(Value: any): string`
* Encodes the provided value into a JSON string

#### `json.parse(Json: string): any`
* Decodes the JSON string and returns it as a value

### `mesh`
* Mesh assets

#### `mesh.save(any): any`
* Saves the mesh data at the provided path to a file

#### `mesh.set(any): any`
* Associates the provided mesh data with the provided path

#### `mesh.get(any): any`
* Returns the provided mesh data associated with the provided path

### `model`
* `glTF` models

#### `model.import(any): any`
* Imports the glTF model at the provided path and returns it as a list of `GameObject`s

### `net`
* **This API has been disabled due to dependency burden**

#### `net.request(any): any`
* Performs an HTTP request to the given URL and returns the response

### `scene`
* Scene assets

#### `scene.load(Path: string): GameObject?, string?`
* Loads `GameObject`s from the scene file at the provided path, returning a list of the root objects or `nil` and an error message upon failure

#### `scene.save(RootNodes: { GameObject }, Path: string): boolean`
* Saves the list of `GameObject`s to the provided path, returning whether the operation succeeded

### `world`
* World queries

#### `world.aabbcast(any): any`
* Cast an AABB

#### `world.raycast(any): any`
* Cast a ray

#### `world.aabbquery(any): any`
* Query all objects within the provided AABB

## Globals

Other globals.

#### `appendlog(...: any): ()`
* Same as `print`, but does not prefix the log message with `[INFO]`

#### `breakpoint(Line: number): ()`
* Set a breakpoint at the given line

#### `game: GameObject & DataModel`
* The GameObject acting as the Data Model of the Engine

#### `loadfile(File: string, ChunkName: string): ( thread?, string? )`
* Similar to `loadthread`, however loads from a file instead of from a string directly

#### `loadthread(Code: string, ChunkName: string): ( thread?, string? )`
* Like `loadstring` in *other* runtimes, however does not compromise Global Import optimizations and returns a coroutine instead of a function. If an error occurs, returns `nil` as the first value and the error message as the second value

#### `sleep(SleepTime: number): ()`
* Yields the thread for the specified number of seconds

#### `workspace: GameObject & Workspace`
* Shorthand for `game.Workspace`

