## Datatypes

Custom types with functions and properties.

### `Color`

* An RGB color

#### `Color.new(R: number, G: number, B: number): Color`
* Returns a Color with the provided R, G, and B values
* Values are expected to be in the range 0 to 1

#### `.R: number`
* The Red channel

#### `.G: number`
* The Green channel

#### `.B: number`
* The Blue channel

### `GameObject`

* A Game Object
* For organization, the members of this type will be on the Components wiki page

#### `GameObject.new(Component: string): GameObject`
* Creates a new GameObject with the provided Component

### `Matrix`

* A 4x4 transformation matrix

#### `Matrix.new(): Matrix`
* Creates a new identity matrix

#### `Matrix.fromTranslation(( Position: vector ) | ( X: number, Y: number, Z: number )): Matrix`
* Creates a Matrix which has been translated to the given coordinates (specified as either a `vector` or the individual X, Y, and Z component)

#### `Matrix.lookAt(Eye: vector, Target: vector): Matrix`
* Creates a Matrix at position `Eye` oriented such that the `.Forward` vector moves toward `Target`

#### `Matrix.fromEulerAnglesXYZ(X: number, Y: number, Z: number): Matrix`
* Creates a Matrix which has been rotated by the given Euler angles (in radians) with the rotation order X-Y-Z

#### `.Position: vector`
* The position of the Matrix in world-space

#### `.C*R*: number`
* Access the individual values of the Matrix by indexing with the format 'C<Column>R<Row>', where `Column` and `Row` are integers from 1-4, e.g.: `someMatrix.C4R4 == 1`

#### `.Right: vector`
* The rightward vector of the Matrix

#### `.Up: vector`
* The upward vector of the Matrix

#### `.Forward: vector`
* The forward vector of the Matrix

## Libraries

Custom libraries.

### `conf`
* Internal Engine configuration state, loaded from file (`phoenix.conf`) upon startup

#### `conf.save(): boolean`
* Save the current state of the configuration to file (`phoenix.conf`), returning whether the file was successfully overwritten

#### `conf.set(Key: string, Value: any): `
* Change a specific value in the configuration

#### `conf.get(Key: string): any`
* Read a specific value from the configuration

### `engine`
* Inspect and modify various parts of the Engine

#### `engine.exit(ExitCode: number?): `
* Shuts down the Engine and exits the process with the specified Exit Code (or 0 by default)

#### `engine.setfullscreen(...): ...`
* Enables/disables fullscreen mode

#### `engine.getfullscreen(...): ...`
* Returns whether the Engine is currently in fullscreen

#### `engine.setmaxframerate(MaxFramerate: number): `
* Sets the maximum framerate the Engine will reach before self-limiting

#### `engine.setvsync(...): ...`
* Enables/disables VSync

#### `engine.framerate(...): ...`
* Returns the current framerate

#### `engine.getvsync(...): ...`
* Returns whether VSync is currently enabled

#### `engine.getmaxframerate(...): ...`
* Returns the current framerate cap

#### `engine.getwindowsize(...): ...`
* Returns the current size of the window as two integers

#### `engine.dwireframes(Enabled: boolean?): `
* Returns whether all visible 3D objects are being rendered with wireframes
* Optionally, the visualization can be enabled/disabled by passing in a boolean argument

#### `engine.isheadless(...): ...`
* Returns whether the Engine is currently running Headless mode

#### `engine.daabbs(Enabled: boolean?): `
* Returns whether AABBs are drawn for all objects with collisions enabled (`.PhysicsCollisions == true`)
* Optionally, the visualization can be enabled/disabled by passing in a boolean argument

#### `engine.setwindowsize(...): ...`
* Sets the size of the window to the specified two Width and Height integers

### `fs`
* Interacting with the player's filesystem

#### `fs.write(Path: string, Contents: string): boolean`
* Overwrites/creates the file at `Path` with the provided `Contents`
* Returns whether the operation was successful

#### `fs.read(Path: string): string?`
* Reads the file at the given address, and returns the contents
* If the file could not be read, returns `nil`

#### `fs.promptopen(DefaultLocation: string? [ './' ], Filter: string? [ '*.*' ], FilterName: string? [ 'All files ' ], AllowMultipleFiles: boolean [ false ]): { string }`
* Prompts the player to select a file to open
* Returns the list of files the player selected, or an empty list if the player cancelled the dialog
* If the operation fails, returns `nil` instead

#### `fs.isfile(...): ...`
* Returns whether the specified Path refers to a file

#### `fs.promptsave(DefaultLocation: string? [ './' ], Filter: string? [ '*.*' ], FilterName: string? [ 'All files ' ]): string`
* Prompts the player to select a path to save a file to
* Returns the path the player selected, or `nil` if they cancelled the dialog

#### `fs.listdir(Path: string, Filter: 'a' | 'f' | 'd' [ 'a' ]): { [string]: 'f' | 'd' }`
* Returns a table of all the entries in the specified directory
* The keys of the table is the path of the entry, while the values are the type of the entry
* `f` is file, `d` is directory, and `a` is all

#### `fs.isdirectory(...): ...`
* Returns whether the specified Path refers to a directory

#### `fs.ispromptactive(...): ...`
* Returns whether a File Dialog is currently visible to the player and blocking any more file dialogs from being opened

### `imgui`
* UI with Dear ImGui

#### `imgui.checkbox(...): ...`
* `ImGui::Checkbox`

#### `imgui.endw(...): ...`
* `ImGui::End`, `endw` and not `end` because `end` is a Luau keyword

#### `imgui.text(...): ...`
* `ImGui::Text`

#### `imgui.itemhovered(...): ...`
* `ImGui::IsItemHovered`

#### `imgui.itemclicked(...): ...`
* `ImGui::IsItemClicked`

#### `imgui.indent(...): ...`
* `ImGui::Indent`

#### `imgui.image(...): ...`
* `ImGui::Image`

#### `imgui.begin(...): ...`
* `ImGui::Begin`

#### `imgui.setitemtooltip(...): ...`
* `ImGui::SetItemTooltip`

#### `imgui.button(...): ...`
* `ImGui::Button`

#### `imgui.textlink(...): ...`
* `ImGui::TextLink`

#### `imgui.inputnumber(...): ...`
* `ImGui::InputDouble`

#### `imgui.inputstring(...): ...`
* `ImGui::InputText`

### `input`
* Checking player inputs

#### `input.ismousegrabbed(...): ...`
* Returns whether the mouse cursor is currently restricted to the window

#### `input.setmousegrabbed(...): ...`
* Grabs/ungrabs the mouse cursor

#### `input.guihandledm(...): ...`
* Returns whether Dear ImGui is using the player's mouse inputs

#### `input.setmousepos(...): ...`
* Sets the position of the mouse in the window

#### `input.iscursorvisible(...): ...`
* Returns whether the mouse cursor is currently visible

#### `input.setcursorvisible(...): ...`
* Sets the visibility of the mouse cursor to the specified value

#### `input.getmousepos(...): ...`
* Returns the current position of the player's mouse cursor, offset from the top-righ54

#### `input.guihandled(...): ...`
* Returns whether Dear ImGui is using the player's inputs at all

#### `input.mousedown(...): ...`
* Returns whether the specified mouse button (`l`eft, `r`ight, or `b`oth) is currently being pressed

#### `input.keypressed(...): ...`
* Returns whether the specified key (as lowercase, e.g. `'a'`, `'b'`) is currently being pressed

#### `input.guihandledk(...): ...`
* Returns whether Dear ImGui is using the player's keyboard inputs

### `json`
* Encoding and decoding JSON files

#### `json.encode(...): ...`
* Encodes the provided value into a JSON string

#### `json.parse(...): ...`
* Decodes the JSON string and returns it as a value

### `mesh`
* Mesh assets

#### `mesh.save(...): ...`
* Saves the mesh data at the provided path to a file

#### `mesh.set(...): ...`
* Associates the provided mesh data with the provided path

#### `mesh.get(...): ...`
* Returns the provided mesh data associated with the provided path

### `model`
* `glTF` models

#### `model.import(...): ...`
* Imports the glTF model at the provided path and returns it as a list of `GameObject`s

### `net`
* Networking

#### `net.request(...): ...`
* Performs an HTTP request to the given URL and returns the response

### `scene`
* Scene assets

#### `scene.load(...): ...`
* Loads `GameObject`s from the scene file at the provided path, returning a list of the root objects or `nil` and an error message upon failure

#### `scene.save(...): ...`
* Saves the list of `GameObject`s to the provided path

### `world`
* World queries

#### `world.aabbcast(...): ...`
* Cast an AABB

#### `world.raycast(...): ...`
* Cast a ray

#### `world.aabbquery(...): ...`
* Query all objects within the provided AABB

## Globals

Other globals.

#### `appendlog(...: any): ...`
* Same as `print`, but does not prefix the log message with `[INFO]`

#### `game: GameObject`
* The GameObject acting as the Data Model of the Engine

#### `sleep(SleepTime: number): ...`
* Yields the thread for the specified number of seconds

#### `workspace: GameObject`
* Shorthand for `game.Workspace`

